# 实验一

`java -Xmx1g -XX:+UseSerialGC -XX:+PrintGCDetails -XX:+PrintGCDateStamps GCLogAnalysis`

生成7244个对象。

初始分配256M内存，最终共分配了800M内存。

17次gc，14次young gc，3次full gc。每次gc时长是10-40ms。

老年代使用372069K，占68%。

`java -Xms1g -Xmx1g -XX:+UseSerialGC -XX:+PrintGCDetails -XX:+PrintGCDateStamps GCLogAnalysis`

生成9519个对象。

初始即分配1g内存。

9次young gc，0次full gc。每次gc时长是50-60ms。

未发生full gc，老年代使用657787K，占94%。

## 结论

使用SerialGC，在相同时间内，其他条件均一致的前提下，可用内存空间越大，越不容易发生gc。但是一旦发生gc，gc时间较长，因为需要回收的对象更多。

## 问题

观察了以上实验的第一个命令执行结果的gc日志，日志文件请见[gclog.md](./gclog.md)，现象如下。

1. 第一次full gc前，年轻代是78656K，总堆内存是253440K。

2. 第一次full gc时，年轻代空间大小没变，而总堆内存是264172K，扩大了10732K。

3. 在之后最近一次gc时，年轻代空间扩大到125696K，扩大了47040K；总堆内存扩大到404972K，扩大了151532K。

4. 一直持续到第二次full gc时，年轻代空间不变，总堆内存扩大到417016K，扩大了12044K。
5. 在之后最近一次gc时，年轻代扩大到185472K，扩大了59776K；总堆内存扩大到597520K，扩大了192548K。

基于以上观察，我想问以下几个问题：

1. 为何full gc发生时，年轻代空间没变，但是总堆内存却增加了一点，看上去像是先对老年代进行了扩大？

2. 每次堆内存扩大，看上去是年轻的与老年代同时扩大，两者是否始终保持一定比例增大？

3. 堆内存扩大的机制与gc之间有无配合之处，STW是否会暂停堆内存的扩大？